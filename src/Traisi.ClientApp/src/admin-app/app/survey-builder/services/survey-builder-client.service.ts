/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { QuestionTypeDefinition } from '../models/question-type-definition';
import { QuestionOptionValueType } from '../models/question-option-value-type.enum';
import { QuestionBuilderType } from '../models/question-builder-type.enum';
import { QuestionConditionalType } from '../models/question-conditional-type.enum';
import { GeneratedIdsViewModel } from 'shared/models/generated-ids-view-model.model';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
	providedIn: 'root',
})
export class QuestionClient {
	private http: HttpClient;
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
		this.http = http;
		this.baseUrl = baseUrl ? baseUrl : '';
	}

	customBuilderClientCode(questionType: string | null): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/Question/client-code/builder/{questionType}';
		if (questionType === undefined || questionType === null)
			throw new Error("The parameter 'questionType' must be defined.");
		url_ = url_.replace('{questionType}', encodeURIComponent('' + questionType));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processCustomBuilderClientCode(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processCustomBuilderClientCode(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processCustomBuilderClientCode(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	clientCode(questionType: string | null): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/Question/client-code/{questionType}';
		if (questionType === undefined || questionType === null)
			throw new Error("The parameter 'questionType' must be defined.");
		url_ = url_.replace('{questionType}', encodeURIComponent('' + questionType));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processClientCode(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processClientCode(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processClientCode(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	clientBuilderCode(questionType: string | null): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/Question/client-builder-code/{questionType}';
		if (questionType === undefined || questionType === null)
			throw new Error("The parameter 'questionType' must be defined.");
		url_ = url_.replace('{questionType}', encodeURIComponent('' + questionType));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processClientBuilderCode(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processClientBuilderCode(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processClientBuilderCode(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	questionTypes(): Observable<QuestionTypeDefinition[]> {
		let url_ = this.baseUrl + '/api/Question/question-types';
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processQuestionTypes(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processQuestionTypes(<any>response_);
						} catch (e) {
							return <Observable<QuestionTypeDefinition[]>>(<any>_observableThrow(e));
						}
					} else return <Observable<QuestionTypeDefinition[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processQuestionTypes(response: HttpResponseBase): Observable<QuestionTypeDefinition[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <QuestionTypeDefinition[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<QuestionTypeDefinition[]>(<any>null);
	}

	getQuestionConfiguration(questionType: string | null): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/Question/configurations/{questionType}';
		if (questionType === undefined || questionType === null)
			throw new Error("The parameter 'questionType' must be defined.");
		url_ = url_.replace('{questionType}', encodeURIComponent('' + questionType));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetQuestionConfiguration(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetQuestionConfiguration(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetQuestionConfiguration(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}
}

@Injectable({
	providedIn: 'root',
})
export class SurveyBuilderClient {
	private http: HttpClient;
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
		this.http = http;
		this.baseUrl = baseUrl ? baseUrl : '';
	}

	questionTypes(): Observable<SBQuestionTypeDefinitionViewModel[]> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/question-types';
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processQuestionTypes(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processQuestionTypes(<any>response_);
						} catch (e) {
							return <Observable<SBQuestionTypeDefinitionViewModel[]>>(<any>_observableThrow(e));
						}
					} else return <Observable<SBQuestionTypeDefinitionViewModel[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processQuestionTypes(response: HttpResponseBase): Observable<SBQuestionTypeDefinitionViewModel[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <SBQuestionTypeDefinitionViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<SBQuestionTypeDefinitionViewModel[]>(<any>null);
	}

	generateCATIView(surveyId: number, language: string | null): Observable<SBSurveyViewViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/GenerateCATIView/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGenerateCATIView(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGenerateCATIView(<any>response_);
						} catch (e) {
							return <Observable<SBSurveyViewViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<SBSurveyViewViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGenerateCATIView(response: HttpResponseBase): Observable<SBSurveyViewViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <SBSurveyViewViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<SBSurveyViewViewModel>(<any>null);
	}

	deleteCATIView(surveyId: number, language: string | null): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/DeleteCATIView/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('delete', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processDeleteCATIView(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processDeleteCATIView(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processDeleteCATIView(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getSurveyViewPageStructure(
		surveyId: number,
		surveyViewName: string | null,
		language: string | null
	): Observable<SBSurveyViewViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/PageStructure/{surveyViewName}/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetSurveyViewPageStructure(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetSurveyViewPageStructure(<any>response_);
						} catch (e) {
							return <Observable<SBSurveyViewViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<SBSurveyViewViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetSurveyViewPageStructure(response: HttpResponseBase): Observable<SBSurveyViewViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <SBSurveyViewViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<SBSurveyViewViewModel>(<any>null);
	}

	updateSurveyViewPageOrder(
		surveyId: number,
		surveyViewName: string | null,
		pageViewId: number,
		pageOrder: SBOrderViewModel[] | null
	): Observable<FileResponse> {
		let url_ =
			this.baseUrl + '/api/SurveyBuilder/{surveyId}/PageStructure/{surveyViewName}/UpdateOrder/{pageViewId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (pageViewId === undefined || pageViewId === null)
			throw new Error("The parameter 'pageViewId' must be defined.");
		url_ = url_.replace('{pageViewId}', encodeURIComponent('' + pageViewId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(pageOrder);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateSurveyViewPageOrder(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateSurveyViewPageOrder(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateSurveyViewPageOrder(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	addQuestionPartView(
		surveyId: number,
		surveyViewName: string | null,
		parentQuestionPartViewId: number,
		initialLanguage: string | null,
		questionInfo: SBQuestionPartViewViewModel | null
	): Observable<FileResponse> {
		let url_ =
			this.baseUrl +
			'/api/SurveyBuilder/{surveyId}/Part/{surveyViewName}/{parentQuestionPartViewId}/{initialLanguage}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (parentQuestionPartViewId === undefined || parentQuestionPartViewId === null)
			throw new Error("The parameter 'parentQuestionPartViewId' must be defined.");
		url_ = url_.replace('{parentQuestionPartViewId}', encodeURIComponent('' + parentQuestionPartViewId));
		if (initialLanguage === undefined || initialLanguage === null)
			throw new Error("The parameter 'initialLanguage' must be defined.");
		url_ = url_.replace('{initialLanguage}', encodeURIComponent('' + initialLanguage));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(questionInfo);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processAddQuestionPartView(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processAddQuestionPartView(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processAddQuestionPartView(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	deleteQuestionPartView(
		surveyId: number,
		parentQuestionPartViewId: number,
		childQuestionPartViewId: number
	): Observable<FileResponse> {
		let url_ =
			this.baseUrl + '/api/SurveyBuilder/{surveyId}/Part/{parentQuestionPartViewId}/{childQuestionPartViewId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (parentQuestionPartViewId === undefined || parentQuestionPartViewId === null)
			throw new Error("The parameter 'parentQuestionPartViewId' must be defined.");
		url_ = url_.replace('{parentQuestionPartViewId}', encodeURIComponent('' + parentQuestionPartViewId));
		if (childQuestionPartViewId === undefined || childQuestionPartViewId === null)
			throw new Error("The parameter 'childQuestionPartViewId' must be defined.");
		url_ = url_.replace('{childQuestionPartViewId}', encodeURIComponent('' + childQuestionPartViewId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('delete', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processDeleteQuestionPartView(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processDeleteQuestionPartView(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processDeleteQuestionPartView(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateQuestionPartViewData(
		surveyId: number,
		updatedQPartView: SBQuestionPartViewViewModel | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/Part';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(updatedQPartView);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateQuestionPartViewData(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateQuestionPartViewData(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateQuestionPartViewData(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getQuestionPartViewStructure(
		surveyId: number,
		questionPartViewId: number,
		language: string | null
	): Observable<SBQuestionPartViewViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/PartStructure/{questionPartViewId}/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartViewId === undefined || questionPartViewId === null)
			throw new Error("The parameter 'questionPartViewId' must be defined.");
		url_ = url_.replace('{questionPartViewId}', encodeURIComponent('' + questionPartViewId));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetQuestionPartViewStructure(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetQuestionPartViewStructure(<any>response_);
						} catch (e) {
							return <Observable<SBQuestionPartViewViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<SBQuestionPartViewViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetQuestionPartViewStructure(response: HttpResponseBase): Observable<SBQuestionPartViewViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <SBQuestionPartViewViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<SBQuestionPartViewViewModel>(<any>null);
	}

	getQuestionPartConfigurations(
		surveyId: number,
		questionPartId: number
	): Observable<QuestionConfigurationValueViewModel[]> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionConfigurations/{questionPartId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetQuestionPartConfigurations(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetQuestionPartConfigurations(<any>response_);
						} catch (e) {
							return <Observable<QuestionConfigurationValueViewModel[]>>(<any>_observableThrow(e));
						}
					} else return <Observable<QuestionConfigurationValueViewModel[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetQuestionPartConfigurations(
		response: HttpResponseBase
	): Observable<QuestionConfigurationValueViewModel[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <QuestionConfigurationValueViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<QuestionConfigurationValueViewModel[]>(<any>null);
	}

	updateQuestionPartConfigurations(
		surveyId: number,
		questionPartId: number,
		updatedConfigurations: QuestionConfigurationValueViewModel[] | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionConfigurations/{questionPartId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(updatedConfigurations);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateQuestionPartConfigurations(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateQuestionPartConfigurations(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateQuestionPartConfigurations(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getQuestionPartViewConditionals(
		surveyId: number,
		questionPartViewId: number
	): Observable<QuestionConditionalOperatorViewModel[]> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionConditionals/{questionPartViewId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartViewId === undefined || questionPartViewId === null)
			throw new Error("The parameter 'questionPartViewId' must be defined.");
		url_ = url_.replace('{questionPartViewId}', encodeURIComponent('' + questionPartViewId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetQuestionPartViewConditionals(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetQuestionPartViewConditionals(<any>response_);
						} catch (e) {
							return <Observable<QuestionConditionalOperatorViewModel[]>>(<any>_observableThrow(e));
						}
					} else
						return <Observable<QuestionConditionalOperatorViewModel[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetQuestionPartViewConditionals(
		response: HttpResponseBase
	): Observable<QuestionConditionalOperatorViewModel[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <QuestionConditionalOperatorViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<QuestionConditionalOperatorViewModel[]>(<any>null);
	}

	setQuestionPartConditionals(
		surveyId: number,
		questionPartId: number,
		conditionals: QuestionConditionalOperatorViewModel[] | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionConditionals/{questionPartId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(conditionals);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processSetQuestionPartConditionals(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processSetQuestionPartConditionals(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processSetQuestionPartConditionals(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getQuestionPartOptionConditionals(
		surveyId: number,
		questionPartId: number
	): Observable<QuestionOptionConditionalViewModel[]> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionOptionConditionals/{questionPartId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetQuestionPartOptionConditionals(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetQuestionPartOptionConditionals(<any>response_);
						} catch (e) {
							return <Observable<QuestionOptionConditionalViewModel[]>>(<any>_observableThrow(e));
						}
					} else return <Observable<QuestionOptionConditionalViewModel[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetQuestionPartOptionConditionals(
		response: HttpResponseBase
	): Observable<QuestionOptionConditionalViewModel[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <QuestionOptionConditionalViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<QuestionOptionConditionalViewModel[]>(<any>null);
	}

	setQuestionPartOptionConditionals(
		surveyId: number,
		questionPartId: number,
		conditionals: QuestionOptionConditionalViewModel[] | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionOptionConditionals/{questionPartId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(conditionals);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processSetQuestionPartOptionConditionals(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processSetQuestionPartOptionConditionals(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processSetQuestionPartOptionConditionals(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getSurveyViewPagesWithQuestionsAndOptions(
		surveyId: number,
		surveyViewName: string | null,
		language: string | null
	): Observable<SBPageStructureViewModel[]> {
		let url_ =
			this.baseUrl + '/api/SurveyBuilder/{surveyId}/PageStructure/{surveyViewName}/{language}/QuestionsOptions';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetSurveyViewPagesWithQuestionsAndOptions(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetSurveyViewPagesWithQuestionsAndOptions(<any>response_);
						} catch (e) {
							return <Observable<SBPageStructureViewModel[]>>(<any>_observableThrow(e));
						}
					} else return <Observable<SBPageStructureViewModel[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetSurveyViewPagesWithQuestionsAndOptions(
		response: HttpResponseBase
	): Observable<SBPageStructureViewModel[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <SBPageStructureViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<SBPageStructureViewModel[]>(<any>null);
	}

	getQuestionPartOptions(
		surveyId: number,
		questionPartId: number,
		language: string | null
	): Observable<QuestionOptionValueViewModel[]> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionOptions/{questionPartId}/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetQuestionPartOptions(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetQuestionPartOptions(<any>response_);
						} catch (e) {
							return <Observable<QuestionOptionValueViewModel[]>>(<any>_observableThrow(e));
						}
					} else return <Observable<QuestionOptionValueViewModel[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetQuestionPartOptions(response: HttpResponseBase): Observable<QuestionOptionValueViewModel[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <QuestionOptionValueViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<QuestionOptionValueViewModel[]>(<any>null);
	}

	setQuestionPartOption(
		surveyId: number,
		questionPartId: number,
		newOption: QuestionOptionValueViewModel | null
	): Observable<QuestionOptionValueViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionOptions/{questionPartId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(newOption);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('post', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processSetQuestionPartOption(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processSetQuestionPartOption(<any>response_);
						} catch (e) {
							return <Observable<QuestionOptionValueViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<QuestionOptionValueViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processSetQuestionPartOption(response: HttpResponseBase): Observable<QuestionOptionValueViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <QuestionOptionValueViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<QuestionOptionValueViewModel>(<any>null);
	}

	importQuestionPartOptions(surveyId: number, questionPartId: number): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionOptions/{questionPartId}/massImport';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('post', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processImportQuestionPartOptions(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processImportQuestionPartOptions(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processImportQuestionPartOptions(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	deleteQuestionPartOption(surveyId: number, questionPartId: number, optionId: number): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionOptions/{questionPartId}/{optionId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		if (optionId === undefined || optionId === null) throw new Error("The parameter 'optionId' must be defined.");
		url_ = url_.replace('{optionId}', encodeURIComponent('' + optionId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('delete', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processDeleteQuestionPartOption(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processDeleteQuestionPartOption(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processDeleteQuestionPartOption(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateQuestionPartOptionsOrder(
		surveyId: number,
		questionPartId: number,
		updatedOrder: SBOrderViewModel[] | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/QuestionOptions/{questionPartId}/Order';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartId === undefined || questionPartId === null)
			throw new Error("The parameter 'questionPartId' must be defined.");
		url_ = url_.replace('{questionPartId}', encodeURIComponent('' + questionPartId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(updatedOrder);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateQuestionPartOptionsOrder(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateQuestionPartOptionsOrder(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateQuestionPartOptionsOrder(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateQuestionPartViewOrder(
		surveyId: number,
		surveyViewName: string | null,
		questionPartViewId: number,
		questionPartViewMovedId: number,
		questionOrder: SBOrderViewModel[] | null
	): Observable<FileResponse> {
		let url_ =
			this.baseUrl +
			'/api/SurveyBuilder/{surveyId}/PartStructure/{surveyViewName}/{questionPartViewId}/UpdateOrder/{questionPartViewMovedId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (questionPartViewId === undefined || questionPartViewId === null)
			throw new Error("The parameter 'questionPartViewId' must be defined.");
		url_ = url_.replace('{questionPartViewId}', encodeURIComponent('' + questionPartViewId));
		if (questionPartViewMovedId === undefined || questionPartViewMovedId === null)
			throw new Error("The parameter 'questionPartViewMovedId' must be defined.");
		url_ = url_.replace('{questionPartViewMovedId}', encodeURIComponent('' + questionPartViewMovedId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(questionOrder);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateQuestionPartViewOrder(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateQuestionPartViewOrder(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateQuestionPartViewOrder(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getSurveyStyles(surveyId: number): Observable<string> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/Styles';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetSurveyStyles(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetSurveyStyles(<any>response_);
						} catch (e) {
							return <Observable<string>>(<any>_observableThrow(e));
						}
					} else return <Observable<string>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetSurveyStyles(response: HttpResponseBase): Observable<string> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 = _responseText === '' ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<string>(<any>null);
	}

	updateSurveyStyles(surveyId: number, updatedStyles: string | null): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/Styles';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(updatedStyles);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateSurveyStyles(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateSurveyStyles(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateSurveyStyles(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	extensions(surveyId: number): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/extensions';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processExtensions(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processExtensions(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processExtensions(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	extensionConfiguration(
		surveyId: number,
		extensionName: string | null,
		configuration: any | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/extensions?';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (extensionName === undefined) throw new Error("The parameter 'extensionName' must be defined.");
		else url_ += 'extensionName=' + encodeURIComponent('' + extensionName) + '&';
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(configuration);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('post', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processExtensionConfiguration(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processExtensionConfiguration(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processExtensionConfiguration(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	extensionConfiguration2(
		surveyId: number,
		extensionName: string | null,
		configuration: any | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/extensions?';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (extensionName === undefined) throw new Error("The parameter 'extensionName' must be defined.");
		else url_ += 'extensionName=' + encodeURIComponent('' + extensionName) + '&';
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(configuration);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processExtensionConfiguration2(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processExtensionConfiguration2(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processExtensionConfiguration2(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	extensionConfiguration3(
		surveyId: number,
		extensionName: string | null,
		configuration: any | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/extensions/{extensionName}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (extensionName === undefined || extensionName === null)
			throw new Error("The parameter 'extensionName' must be defined.");
		url_ = url_.replace('{extensionName}', encodeURIComponent('' + extensionName));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(configuration);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('post', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processExtensionConfiguration3(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processExtensionConfiguration3(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processExtensionConfiguration3(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	extensionConfiguration4(
		surveyId: number,
		extensionName: string | null,
		configuration: any | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/extensions/{extensionName}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (extensionName === undefined || extensionName === null)
			throw new Error("The parameter 'extensionName' must be defined.");
		url_ = url_.replace('{extensionName}', encodeURIComponent('' + extensionName));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(configuration);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processExtensionConfiguration4(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processExtensionConfiguration4(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processExtensionConfiguration4(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getWelcomePageLabel(
		surveyId: number,
		surveyViewName: string | null,
		language: string | null
	): Observable<WelcomePageLabelViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/WelcomePage/{surveyViewName}/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetWelcomePageLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetWelcomePageLabel(<any>response_);
						} catch (e) {
							return <Observable<WelcomePageLabelViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<WelcomePageLabelViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetWelcomePageLabel(response: HttpResponseBase): Observable<WelcomePageLabelViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <WelcomePageLabelViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<WelcomePageLabelViewModel>(<any>null);
	}

	getThankYouPageLabel(
		surveyId: number,
		surveyViewName: string | null,
		language: string | null
	): Observable<ThankYouPageLabelViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/ThankYouPage/{surveyViewName}/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetThankYouPageLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetThankYouPageLabel(<any>response_);
						} catch (e) {
							return <Observable<ThankYouPageLabelViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<ThankYouPageLabelViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetThankYouPageLabel(response: HttpResponseBase): Observable<ThankYouPageLabelViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <ThankYouPageLabelViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<ThankYouPageLabelViewModel>(<any>null);
	}

	getTermsAndConditionsPageLabel(
		surveyId: number,
		surveyViewName: string | null,
		language: string | null
	): Observable<TermsAndConditionsPageLabelViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/TermsAndConditionsPage/{surveyViewName}/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetTermsAndConditionsPageLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetTermsAndConditionsPageLabel(<any>response_);
						} catch (e) {
							return <Observable<TermsAndConditionsPageLabelViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<TermsAndConditionsPageLabelViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetTermsAndConditionsPageLabel(
		response: HttpResponseBase
	): Observable<TermsAndConditionsPageLabelViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <TermsAndConditionsPageLabelViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<TermsAndConditionsPageLabelViewModel>(<any>null);
	}

	getScreeningQuestionsLabel(
		surveyId: number,
		surveyViewName: string | null,
		language: string | null
	): Observable<ScreeningQuestionsLabelViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/ScreeningQuestions/{surveyViewName}/{language}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (language === undefined || language === null) throw new Error("The parameter 'language' must be defined.");
		url_ = url_.replace('{language}', encodeURIComponent('' + language));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetScreeningQuestionsLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetScreeningQuestionsLabel(<any>response_);
						} catch (e) {
							return <Observable<ScreeningQuestionsLabelViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<ScreeningQuestionsLabelViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetScreeningQuestionsLabel(
		response: HttpResponseBase
	): Observable<ScreeningQuestionsLabelViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <ScreeningQuestionsLabelViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<ScreeningQuestionsLabelViewModel>(<any>null);
	}

	updateWelcomePageLabel(
		surveyId: number,
		welcomePageLabel: WelcomePageLabelViewModel | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/WelcomePage';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(welcomePageLabel);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateWelcomePageLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateWelcomePageLabel(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateWelcomePageLabel(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateThankYouPageLabel(
		surveyId: number,
		thankYouPageLabel: ThankYouPageLabelViewModel | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/ThankYouPage';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(thankYouPageLabel);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateThankYouPageLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateThankYouPageLabel(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateThankYouPageLabel(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateSurveyTitleLabel(
		surveyId: number,
		title: string | null,
		language: string | null | undefined
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/title/{title}?';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (title === undefined || title === null) throw new Error("The parameter 'title' must be defined.");
		url_ = url_.replace('{title}', encodeURIComponent('' + title));
		if (language !== undefined) url_ += 'language=' + encodeURIComponent('' + language) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateSurveyTitleLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateSurveyTitleLabel(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateSurveyTitleLabel(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateTermsAndConditionsPageLabel(
		surveyId: number,
		termsAndConditionsPageLabel: TermsAndConditionsPageLabelViewModel | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/TermsAndConditionsPage';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(termsAndConditionsPageLabel);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateTermsAndConditionsPageLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateTermsAndConditionsPageLabel(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateTermsAndConditionsPageLabel(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateScreeningQuestionsLabel(
		surveyId: number,
		screeningQuestionsLabel: ScreeningQuestionsLabelViewModel | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/ScreeningQuestions';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(screeningQuestionsLabel);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateScreeningQuestionsLabel(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateScreeningQuestionsLabel(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateScreeningQuestionsLabel(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	addPage(
		surveyId: number,
		surveyViewName: string | null,
		initialLanguage: string | null,
		pageInfo: SBQuestionPartViewViewModel | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/Page/{surveyViewName}/{initialLanguage}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (initialLanguage === undefined || initialLanguage === null)
			throw new Error("The parameter 'initialLanguage' must be defined.");
		url_ = url_.replace('{initialLanguage}', encodeURIComponent('' + initialLanguage));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(pageInfo);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('post', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processAddPage(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processAddPage(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processAddPage(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	deletePage(surveyId: number, surveyViewName: string | null, pageId: number): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/Page/{surveyViewName}/{pageId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyViewName === undefined || surveyViewName === null)
			throw new Error("The parameter 'surveyViewName' must be defined.");
		url_ = url_.replace('{surveyViewName}', encodeURIComponent('' + surveyViewName));
		if (pageId === undefined || pageId === null) throw new Error("The parameter 'pageId' must be defined.");
		url_ = url_.replace('{pageId}', encodeURIComponent('' + pageId));
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('delete', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processDeletePage(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processDeletePage(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processDeletePage(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateQuestionConditionals(
		surveyId: number,
		questionPartViewId: number,
		conditionals: QuestionConditionalOperatorViewModel[] | null
	): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/{surveyId}/conditionals/{questionPartViewId}';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (questionPartViewId === undefined || questionPartViewId === null)
			throw new Error("The parameter 'questionPartViewId' must be defined.");
		url_ = url_.replace('{questionPartViewId}', encodeURIComponent('' + questionPartViewId));
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(conditionals);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('post', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateQuestionConditionals(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateQuestionConditionals(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateQuestionConditionals(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	updateSurveyLogic(
		surveyId: number,
		language: string | null | undefined,
		surveyLogicViewModel: SurveyLogicViewModel | null
	): Observable<GeneratedIdsViewModel> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/surveys/{surveyId}/survey-logic?';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (language !== undefined) url_ += 'language=' + encodeURIComponent('' + language) + '&';
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(surveyLogicViewModel);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('put', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processUpdateSurveyLogic(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processUpdateSurveyLogic(<any>response_);
						} catch (e) {
							return <Observable<GeneratedIdsViewModel>>(<any>_observableThrow(e));
						}
					} else return <Observable<GeneratedIdsViewModel>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processUpdateSurveyLogic(response: HttpResponseBase): Observable<GeneratedIdsViewModel> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <GeneratedIdsViewModel>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<GeneratedIdsViewModel>(<any>null);
	}

	addSurveyLogic(
		surveyId: number,
		language: string | null | undefined,
		surveyLogicViewModel: SurveyLogicViewModel | null
	): Observable<number> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/surveys/{surveyId}/survey-logic?';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (language !== undefined) url_ += 'language=' + encodeURIComponent('' + language) + '&';
		url_ = url_.replace(/[?&]$/, '');

		const content_ = JSON.stringify(surveyLogicViewModel);

		let options_: any = {
			body: content_,
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				'Content-Type': 'application/json',
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('post', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processAddSurveyLogic(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processAddSurveyLogic(<any>response_);
						} catch (e) {
							return <Observable<number>>(<any>_observableThrow(e));
						}
					} else return <Observable<number>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processAddSurveyLogic(response: HttpResponseBase): Observable<number> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 = _responseText === '' ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<number>(<any>null);
	}

	deleteSurveyLogic(surveyId: number, surveyLogicId: number): Observable<FileResponse> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/surveys/{surveyId}/survey-logic?';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (surveyLogicId === undefined || surveyLogicId === null)
			throw new Error("The parameter 'surveyLogicId' must be defined and cannot be null.");
		else url_ += 'surveyLogicId=' + encodeURIComponent('' + surveyLogicId) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/octet-stream',
			}),
		};

		return this.http
			.request('delete', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processDeleteSurveyLogic(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processDeleteSurveyLogic(<any>response_);
						} catch (e) {
							return <Observable<FileResponse>>(<any>_observableThrow(e));
						}
					} else return <Observable<FileResponse>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processDeleteSurveyLogic(response: HttpResponseBase): Observable<FileResponse> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200 || status === 206) {
			const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
			const fileNameMatch = contentDisposition
				? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
				: undefined;
			const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
			return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<FileResponse>(<any>null);
	}

	getSurveyLogic(surveyId: number, language: string | null | undefined): Observable<SurveyLogicViewModel[]> {
		let url_ = this.baseUrl + '/api/SurveyBuilder/surveys/{surveyId}/survey-logic?';
		if (surveyId === undefined || surveyId === null) throw new Error("The parameter 'surveyId' must be defined.");
		url_ = url_.replace('{surveyId}', encodeURIComponent('' + surveyId));
		if (language !== undefined) url_ += 'language=' + encodeURIComponent('' + language) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: any = {
			observe: 'response',
			responseType: 'blob',
			headers: new HttpHeaders({
				Accept: 'application/json',
			}),
		};

		return this.http
			.request('get', url_, options_)
			.pipe(
				_observableMergeMap((response_: any) => {
					return this.processGetSurveyLogic(response_);
				})
			)
			.pipe(
				_observableCatch((response_: any) => {
					if (response_ instanceof HttpResponseBase) {
						try {
							return this.processGetSurveyLogic(<any>response_);
						} catch (e) {
							return <Observable<SurveyLogicViewModel[]>>(<any>_observableThrow(e));
						}
					} else return <Observable<SurveyLogicViewModel[]>>(<any>_observableThrow(response_));
				})
			);
	}

	protected processGetSurveyLogic(response: HttpResponseBase): Observable<SurveyLogicViewModel[]> {
		const status = response.status;
		const responseBlob =
			response instanceof HttpResponse
				? response.body
				: (<any>response).error instanceof Blob
				? (<any>response).error
				: undefined;

		let _headers: any = {};
		if (response.headers) {
			for (let key of response.headers.keys()) {
				_headers[key] = response.headers.get(key);
			}
		}
		if (status === 200) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					let result200: any = null;
					result200 =
						_responseText === ''
							? null
							: <SurveyLogicViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
					return _observableOf(result200);
				})
			);
		} else if (status !== 200 && status !== 204) {
			return blobToText(responseBlob).pipe(
				_observableMergeMap((_responseText) => {
					return throwException('An unexpected server error occurred.', status, _responseText, _headers);
				})
			);
		}
		return _observableOf<SurveyLogicViewModel[]>(<any>null);
	}
}

export interface MarshalByRefObject {}

export interface FileSystemInfo extends MarshalByRefObject {
	fullName?: string | undefined;
	extension?: string | undefined;
	name?: string | undefined;
	exists?: boolean;
	creationTime?: Date;
	creationTimeUtc?: Date;
	lastAccessTime?: Date;
	lastAccessTimeUtc?: Date;
	lastWriteTime?: Date;
	lastWriteTimeUtc?: Date;
	attributes?: FileAttributes;
}

export interface DirectoryInfo extends FileSystemInfo {
	parent?: DirectoryInfo | undefined;
	root?: DirectoryInfo | undefined;
}

export enum FileAttributes {
	ReadOnly = 1,
	Hidden = 2,
	System = 4,
	Directory = 16,
	Archive = 32,
	Device = 64,
	Normal = 128,
	Temporary = 256,
	SparseFile = 512,
	ReparsePoint = 1024,
	Compressed = 2048,
	Offline = 4096,
	NotContentIndexed = 8192,
	Encrypted = 16384,
	IntegrityStream = 32768,
	NoScrubData = 131072,
}

export interface QuestionOptionDefinition {
	name?: string | undefined;
	description?: string | undefined;
	valueType?: QuestionOptionValueType;
	typeId?: any | undefined;
	defaultValue?: string | undefined;
	isMultipleAllowed?: boolean;
}

export interface QuestionConfigurationDefinition {
	name?: string | undefined;
	description?: string | undefined;
	valueType?: ConfigurationValueType;
	builderType?: QuestionBuilderType;
	typeId?: any | undefined;
	defaultValue?: any | undefined;
	sharedResource?: string | undefined;
	resourceData?: string | undefined;
	isTranslatable?: boolean;
	configuration?: { [key: string]: string } | undefined;
}

export enum ConfigurationValueType {
	String = 0,
	Integer = 1,
	Decimal = 2,
	Boolean = 3,
	Tuple = 4,
	Time = 5,
	Date = 6,
	Custom = 7,
	Label = 8,
	Question = 9,
	KeyValuePair = 10,
}

export interface QuestionPartSlotDefinition {
	name?: string | undefined;
	description?: string | undefined;
	slotOrder?: number;
}

export interface ISurveyQuestion {
	typeName?: string | undefined;
	icon?: string | undefined;
	iconType?: QuestionIconType;
}

export enum QuestionIconType {
	URL = 0,
	FONT = 1,
}

export interface QuestionResource {
	resourceName?: string | undefined;
	data?: string | undefined;
	fieldName?: string | undefined;
}

export interface ResponseValidator {}

export interface NestedQuestionDefinition {
	name?: string | undefined;
}

export interface SBQuestionTypeDefinitionViewModel {
	typeName?: string | undefined;
	questionOptions?: { [key: string]: QuestionOptionDefinitionViewModel } | undefined;
	questionConfigurations?: { [key: string]: QuestionConfigurationDefinitionViewModel } | undefined;
	icon?: string | undefined;
	responseType?: string | undefined;
	typeNameLocales?: { [key: string]: string } | undefined;
	hasCustomBuilderView?: boolean;
	customBuilderViewName?: string | undefined;
}

export interface QuestionOptionDefinitionViewModel {
	name?: string | undefined;
	description?: string | undefined;
	valueType?: string | undefined;
	defaultValue?: string | undefined;
	isMultipleAllowed?: boolean;
}

export interface QuestionConfigurationDefinitionViewModel {
	name?: string | undefined;
	description?: string | undefined;
	valueType?: string | undefined;
	builderType?: string | undefined;
	defaultValue?: string | undefined;
	resourceData?: string | undefined;
}

export interface SBSurveyViewViewModel {
	id?: number;
	surveyId?: number;
	viewName?: string | undefined;
	pages?: SBQuestionPartViewViewModel[] | undefined;
	termsAndConditionsPage?: TermsAndConditionsPageLabelViewModel | undefined;
	welcomePage?: WelcomePageLabelViewModel | undefined;
	surveyCompletionPage?: ThankYouPageLabelViewModel | undefined;
	screeningQuestions?: ScreeningQuestionsLabelViewModel | undefined;
}

export interface SBQuestionPartViewViewModel {
	id?: number;
	questionPart?: SBQuestionPartViewModel | undefined;
	label?: LabelViewModel | undefined;
	parentViewId?: number | undefined;
	questionPartViewChildren?: SBQuestionPartViewViewModel[] | undefined;
	order?: number;
	isOptional?: boolean;
	isHousehold?: boolean;
	repeatSourceQuestionName?: string | undefined;
	icon?: string | undefined;
	isMultiView?: boolean;
	catiDependent?: SBQuestionPartViewViewModel | undefined;
}

export interface SBQuestionPartViewModel {
	id?: number;
	questionType?: string | undefined;
	name?: string | undefined;
	questionPartChildren?: SBQuestionPartViewModel[] | undefined;
	isGroupQuestion?: boolean;
}

export interface LabelViewModel {
	value?: string | undefined;
	language?: string | undefined;
}

export interface TermsAndConditionsPageLabelViewModel extends LabelViewModel {
	id?: number;
	surveyViewId?: number;
}

export interface WelcomePageLabelViewModel extends LabelViewModel {
	id?: number;
	surveyViewId?: number;
}

export interface ThankYouPageLabelViewModel extends LabelViewModel {
	id?: number;
	surveyViewId?: number;
}

export interface ScreeningQuestionsLabelViewModel extends LabelViewModel {
	id?: number;
	surveyViewId?: number;
}

export interface SBOrderViewModel {
	id?: number;
	order?: number;
}

export interface QuestionConfigurationValueViewModel {
	name?: string | undefined;
	value?: any | undefined;
}

export interface QuestionConditionalOperatorViewModel {
	lhs?: QuestionConditionalViewModel | undefined;
	rhs?: QuestionConditionalViewModel | undefined;
	id?: number;
	order?: number;
	targetQuestionId?: number;
	operatorType?: QuestionCondtionalOperatorType;
}

export interface QuestionConditionalViewModel {
	id?: number;
	sourceQuestionId?: number;
	condition?: QuestionConditionalType;
	value?: string | undefined;
}

export enum QuestionCondtionalOperatorType {
	AND = 0,
	OR = 1,
}

export interface QuestionOptionConditionalViewModel {
	id?: number;
	targetOptionId?: number;
	sourceQuestionId?: number;
	condition?: string | undefined;
	value?: string | undefined;
}

export interface SBPageStructureViewModel {
	id?: string | undefined;
	label?: string | undefined;
	type?: string | undefined;
	children?: SBPageStructureViewModel[] | undefined;
}

export interface QuestionOptionValueViewModel {
	id?: number;
	name?: string | undefined;
	code?: string | undefined;
	optionLabel?: LabelViewModel | undefined;
	order?: number;
}

export interface SurveyLogicBaseViewModel {}

export interface SurveyLogicViewModel extends SurveyLogicBaseViewModel {
	id?: number | undefined;
	message?: string | undefined;
	condition?: string | undefined;
	rules?: SurveyLogicViewModel[] | undefined;
	field?: string | undefined;
	operator?: string | undefined;
	value?: any | undefined;
}

export interface FileResponse {
	data: Blob;
	status: number;
	fileName?: string;
	headers?: { [name: string]: any };
}

export class ApiException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;

	constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any
): Observable<any> {
	if (result !== null && result !== undefined) return _observableThrow(result);
	else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
	return new Observable<string>((observer: any) => {
		if (!blob) {
			observer.next('');
			observer.complete();
		} else {
			let reader = new FileReader();
			reader.onload = (event) => {
				observer.next((<any>event.target).result);
				observer.complete();
			};
			reader.readAsText(blob);
		}
	});
}
