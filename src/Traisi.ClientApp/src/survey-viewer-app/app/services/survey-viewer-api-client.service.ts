/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class SurveyRespondentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getSurveyPrimaryRespondent(surveyId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/surveys/{surveyId}/respondents/primary";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyPrimaryRespondent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyPrimaryRespondent(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyPrimaryRespondent(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    addSurveyGroupMember(respondent: SurveyRespondentViewModel | null): Observable<number> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/respondents/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(respondent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSurveyGroupMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSurveyGroupMember(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddSurveyGroupMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateSurveyGroupMember(respondent: SurveyRespondentViewModel | null): Observable<void> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/respondents/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(respondent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSurveyGroupMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSurveyGroupMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSurveyGroupMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    removeSurveyGroupMember(respondentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/groups/respondents/{respondentId}";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSurveyGroupMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSurveyGroupMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveSurveyGroupMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    listSurveyGroupMembers(respondentId: number): Observable<SurveyRespondentViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyRespondent/groups/respondents/{respondentId}";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSurveyGroupMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSurveyGroupMembers(<any>response_);
                } catch (e) {
                    return <Observable<SurveyRespondentViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyRespondentViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processListSurveyGroupMembers(response: HttpResponseBase): Observable<SurveyRespondentViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyRespondentViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyRespondentViewModel[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SurveyResponseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    saveResponse(surveyId: number, questionId: number, respondentId: number, repeat: number, language: string | null | undefined, content: any[] | null): Observable<SurveyViewerResponseValidationState> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/questions/{questionId}/respondents/{respondentId}/{repeat}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (repeat === undefined || repeat === null)
            throw new Error("The parameter 'repeat' must be defined.");
        url_ = url_.replace("{repeat}", encodeURIComponent("" + repeat));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "language": language !== undefined && language !== null ? "" + language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveResponse(<any>response_);
                } catch (e) {
                    return <Observable<SurveyViewerResponseValidationState>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyViewerResponseValidationState>><any>_observableThrow(response_);
        }));
    }

    protected processSaveResponse(response: HttpResponseBase): Observable<SurveyViewerResponseValidationState> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyViewerResponseValidationState>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyViewerResponseValidationState>(<any>null);
    }

    getResponse(surveyId: number, questionId: number, respondentId: number, repeat: number): Observable<SurveyResponseViewModel> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/questions/{questionId}/respondents/{respondentId}/{repeat}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (repeat === undefined || repeat === null)
            throw new Error("The parameter 'repeat' must be defined.");
        url_ = url_.replace("{repeat}", encodeURIComponent("" + repeat));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResponse(<any>response_);
                } catch (e) {
                    return <Observable<SurveyResponseViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyResponseViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetResponse(response: HttpResponseBase): Observable<SurveyResponseViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyResponseViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyResponseViewModel>(<any>null);
    }

    listResponsesOfType(surveyId: number, responseType: QuestionResponseType): Observable<SurveyResponseViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/responses/types/{responseType}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (responseType === undefined || responseType === null)
            throw new Error("The parameter 'responseType' must be defined.");
        url_ = url_.replace("{responseType}", encodeURIComponent("" + responseType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListResponsesOfType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListResponsesOfType(<any>response_);
                } catch (e) {
                    return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processListResponsesOfType(response: HttpResponseBase): Observable<SurveyResponseViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyResponseViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyResponseViewModel[]>(<any>null);
    }

    listSurveyResponsesForQuestions(surveyId: number | undefined, questionIds: number[] | null | undefined, respondentId: number): Observable<SurveyResponseViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyResponse/questions/respondents/{respondentId}/responses?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (questionIds !== undefined)
            questionIds && questionIds.forEach(item => { url_ += "questionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "surveyId": surveyId !== undefined && surveyId !== null ? "" + surveyId : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSurveyResponsesForQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSurveyResponsesForQuestions(<any>response_);
                } catch (e) {
                    return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyResponseViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processListSurveyResponsesForQuestions(response: HttpResponseBase): Observable<SurveyResponseViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyResponseViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyResponseViewModel[]>(<any>null);
    }

    listSurveyResponsesForQuestionsByName(surveyId: number | undefined, questionNames: string[] | null | undefined, respondentId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyResponse/questions/names/respondents/{respondentId}/responses?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (questionNames !== undefined)
            questionNames && questionNames.forEach(item => { url_ += "questionNames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "surveyId": surveyId !== undefined && surveyId !== null ? "" + surveyId : "",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListSurveyResponsesForQuestionsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListSurveyResponsesForQuestionsByName(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processListSurveyResponsesForQuestionsByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyCompletionStatus(surveyId: number, respondentId: number): Observable<SurveyCompletionStatus> {
        let url_ = this.baseUrl + "/api/SurveyResponse/completion-status/primary-respondents/{respondentId}?";
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined and cannot be null.");
        else
            url_ += "surveyId=" + encodeURIComponent("" + surveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyCompletionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyCompletionStatus(<any>response_);
                } catch (e) {
                    return <Observable<SurveyCompletionStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyCompletionStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyCompletionStatus(response: HttpResponseBase): Observable<SurveyCompletionStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyCompletionStatus>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyCompletionStatus>(<any>null);
    }

    deleteAllResponses(surveyId: number, respondentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/SurveyResponse/surveys/{surveyId}/respondents/{respondentId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (respondentId === undefined || respondentId === null)
            throw new Error("The parameter 'respondentId' must be defined.");
        url_ = url_.replace("{respondentId}", encodeURIComponent("" + respondentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllResponses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllResponses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllResponses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SurveyViewerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getSurveyViews(surveyId: number): Observable<SurveyView[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/views/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViews(<any>response_);
                } catch (e) {
                    return <Observable<SurveyView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViews(response: HttpResponseBase): Observable<SurveyView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyView[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyView[]>(<any>null);
    }

    getSurveyFromCode(code: string | null): Observable<number> {
        let url_ = this.baseUrl + "/api/SurveyViewer/codes/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyFromCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyFromCode(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyFromCode(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getSurveyViewQuestions(viewId: number): Observable<SurveyView[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/questions/{viewId}";
        if (viewId === undefined || viewId === null)
            throw new Error("The parameter 'viewId' must be defined.");
        url_ = url_.replace("{viewId}", encodeURIComponent("" + viewId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewQuestions(<any>response_);
                } catch (e) {
                    return <Observable<SurveyView[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyView[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewQuestions(response: HttpResponseBase): Observable<SurveyView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyView[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyView[]>(<any>null);
    }

    getSurveyViewPages(surveyId: number, viewType: SurveyViewType | undefined, language: string | null | undefined): Observable<QuestionPartViewViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/surveys/{surveyId}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (viewType === null)
            throw new Error("The parameter 'viewType' cannot be null.");
        else if (viewType !== undefined)
            url_ += "viewType=" + encodeURIComponent("" + viewType) + "&";
        if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewPages(<any>response_);
                } catch (e) {
                    return <Observable<QuestionPartViewViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionPartViewViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewPages(response: HttpResponseBase): Observable<QuestionPartViewViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QuestionPartViewViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionPartViewViewModel[]>(<any>null);
    }

    getSurveyViewQuestionConfiguration(questionId: number): Observable<QuestionConfiguration> {
        let url_ = this.baseUrl + "/api/SurveyViewer/configurations/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewQuestionConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewQuestionConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<QuestionConfiguration>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionConfiguration>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewQuestionConfiguration(response: HttpResponseBase): Observable<QuestionConfiguration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QuestionConfiguration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionConfiguration>(<any>null);
    }

    getQuestionOptions(surveyId: number, questionId: number, query: string | null | undefined, language: string | null | undefined): Observable<QuestionOptionsViewModel[]> {
        let url_ = this.baseUrl + "/api/SurveyViewer/surveys/{surveyId}/questions/{questionId}/options?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (questionId === undefined || questionId === null)
            throw new Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionOptions(<any>response_);
                } catch (e) {
                    return <Observable<QuestionOptionsViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionOptionsViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionOptions(response: HttpResponseBase): Observable<QuestionOptionsViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QuestionOptionsViewModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionOptionsViewModel[]>(<any>null);
    }

    getDefaultSurveyView(surveyId: number, language: string | null | undefined): Observable<SurveyViewerViewModel> {
        let url_ = this.baseUrl + "/api/SurveyViewer/view/{surveyId}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultSurveyView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultSurveyView(<any>response_);
                } catch (e) {
                    return <Observable<SurveyViewerViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurveyViewerViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultSurveyView(response: HttpResponseBase): Observable<SurveyViewerViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SurveyViewerViewModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurveyViewerViewModel>(<any>null);
    }

    getSurveyStyles(surveyId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/SurveyViewer/styles/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyStyles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyStyles(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyStyles(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    startSurvey(surveyId: number, shortcode: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SurveyViewer/start/{surveyId}/{shortcode}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (shortcode === undefined || shortcode === null)
            throw new Error("The parameter 'shortcode' must be defined.");
        url_ = url_.replace("{shortcode}", encodeURIComponent("" + shortcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartSurvey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartSurvey(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processStartSurvey(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    startSurveyWithGroupcode(surveyId: number, groupcode: string | null, user_Agent: string | null | undefined, queryParams: any | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/start/{surveyId}/groupcode/{groupcode}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (groupcode === undefined || groupcode === null)
            throw new Error("The parameter 'groupcode' must be defined.");
        url_ = url_.replace("{groupcode}", encodeURIComponent("" + groupcode));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(queryParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "User-Agent": user_Agent !== undefined && user_Agent !== null ? "" + user_Agent : "",
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartSurveyWithGroupcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartSurveyWithGroupcode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStartSurveyWithGroupcode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyWelcomeView(name: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/welcome/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyWelcomeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyWelcomeView(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyWelcomeView(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    validateSurveyGroupcode(surveyId: number, groupcode: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/surveys/{surveyId}/groupcodes/{groupcode}/validate";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (groupcode === undefined || groupcode === null)
            throw new Error("The parameter 'groupcode' must be defined.");
        url_ = url_.replace("{groupcode}", encodeURIComponent("" + groupcode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateSurveyGroupcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateSurveyGroupcode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processValidateSurveyGroupcode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getRespondentSurveyViewPageQuestions(surveyId: number, pageNumber: number, language: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/viewer/{surveyId}/page/{pageNumber}?";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRespondentSurveyViewPageQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRespondentSurveyViewPageQuestions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetRespondentSurveyViewPageQuestions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyViewPageQuestions(surveyId: number, pageNumber: number, viewType: SurveyViewType, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/page/{pageNumber}/{viewType}/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined.");
        url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
        if (viewType === undefined || viewType === null)
            throw new Error("The parameter 'viewType' must be defined.");
        url_ = url_.replace("{viewType}", encodeURIComponent("" + viewType));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyViewPageQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyViewPageQuestions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyViewPageQuestions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyTermsAndConditions(surveyId: number, viewType: SurveyViewType, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/terms/{viewType}/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (viewType === undefined || viewType === null)
            throw new Error("The parameter 'viewType' must be defined.");
        url_ = url_.replace("{viewType}", encodeURIComponent("" + viewType));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyTermsAndConditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyTermsAndConditions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyTermsAndConditions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyScreeningQuestions(surveyId: number, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/screening/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyScreeningQuestions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyScreeningQuestions(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyScreeningQuestions(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSurveyThankYou(surveyId: number, viewType: SurveyViewType, language: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/{surveyId}/thankyou/{viewType}/{language}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        if (viewType === undefined || viewType === null)
            throw new Error("The parameter 'viewType' must be defined.");
        url_ = url_.replace("{viewType}", encodeURIComponent("" + viewType));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSurveyThankYou(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSurveyThankYou(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetSurveyThankYou(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    surveyComplete(surveyId: number, shortcode: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/SurveyViewer/complete/{surveyId}";
        if (surveyId === undefined || surveyId === null)
            throw new Error("The parameter 'surveyId' must be defined.");
        url_ = url_.replace("{surveyId}", encodeURIComponent("" + surveyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Shortcode": shortcode !== undefined && shortcode !== null ? "" + shortcode : "",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurveyComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurveyComplete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurveyComplete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface SurveyRespondentViewModel {
    id: number;
    name: string | undefined;
    relationship: string | undefined;
}

export interface SurveyViewerResponseValidationState {
    validationState: ValidationState;
    errorMessages: string[] | undefined;
}

export enum ValidationState {
    Invalid = "invalid",
    Valid = "valid",
    Untouched = "untouched",
}

export interface SurveyResponseViewModel {
    questionId: number;
    responseValues: { [key: string]: any; }[] | undefined;
    configuration: { [key: string]: any; } | undefined;
    respondent: SurveyRespondentViewModel | undefined;
}

export enum QuestionResponseType {
    String = "string",
    Boolean = "boolean",
    Number = "number",
    Location = "location",
    Json = "json",
    OptionSelect = "optionSelect",
    OptionList = "optionList",
    DateTime = "dateTime",
    Time = "time",
    Path = "path",
    Timeline = "timeline",
    None = "none",
}

export interface SurveyCompletionStatus {
    statuses: { [key: string]: RespondentCompletionStatus; } | undefined;
}

export interface RespondentCompletionStatus {
    hasResponse: { [key: string]: boolean; } | undefined;
}

export interface SurveyView {
    survey: Survey | undefined;
    questionPartViews: QuestionPartView[] | undefined;
    welcomePageLabels: LabelCollectionOfLabel | undefined;
    termsAndConditionsLabels: LabelCollectionOfLabel | undefined;
    thankYouPageLabels: LabelCollectionOfLabel | undefined;
    screeningQuestionLabels: LabelCollectionOfLabel | undefined;
    viewName: string | undefined;
}

export interface AuditableEntity {
}

export interface Survey extends AuditableEntity {
    code: string | undefined;
    name: string | undefined;
    owner: string | undefined;
    group: string | undefined;
    startAt: Date;
    endAt: Date;
    isActive: boolean;
    isOpen: boolean;
    successLink: string | undefined;
    rejectionLink: string | undefined;
    defaultLanguage: string | undefined;
    styleTemplate: string | undefined;
    surveyViews: SurveyViewCollectionOfSurveyView | undefined;
    surveyPermissions: SurveyPermission[] | undefined;
    groupCodes: Groupcode[] | undefined;
    shortcodes: Shortcode[] | undefined;
    extensionConfigurations: ExtensionConfiguration[] | undefined;
    titleLabels: LabelCollectionOfLabel | undefined;
    surveyLogic: SurveyLogic[] | undefined;
    hasGroupCodes: boolean;
}

export interface Anonymous {
    Item: SurveyView | undefined;
}

export interface SurveyViewCollectionOfSurveyView extends Anonymous {
}

export interface SurveyPermission {
    id: number;
    userId: string | undefined;
    user: ApplicationUser | undefined;
    surveyId: number;
    survey: Survey | undefined;
    permissionCode: string | undefined;
    permissions: string[] | undefined;
}

export interface IdentityUserOfString {
    id: string | undefined;
    userName: string | undefined;
    normalizedUserName: string | undefined;
    email: string | undefined;
    normalizedEmail: string | undefined;
    emailConfirmed: boolean;
    passwordHash: string | undefined;
    securityStamp: string | undefined;
    concurrencyStamp: string | undefined;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: Date | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

export interface IdentityUser extends IdentityUserOfString {
}

export interface ApplicationUser extends IdentityUser {
    friendlyName: string | undefined;
    jobTitle: string | undefined;
    fullName: string | undefined;
    configuration: string | undefined;
    isEnabled: boolean;
    isLockedOut: boolean;
    createdBy: string | undefined;
    updatedBy: string | undefined;
    createdDate: Date;
    updatedDate: Date;
    roles: IdentityUserRoleOfString[] | undefined;
    claims: IdentityUserClaimOfString[] | undefined;
}

export interface IdentityUserRoleOfString {
    userId: string | undefined;
    roleId: string | undefined;
}

export interface IdentityUserClaimOfString {
    id: number;
    userId: string | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export interface Groupcode {
    id: number;
    survey: Survey | undefined;
    name: string | undefined;
    code: string | undefined;
    createdDate: Date;
    isTest: boolean;
}

export interface Shortcode {
    id: number;
    survey: Survey | undefined;
    groupcode: Groupcode | undefined;
    code: string | undefined;
    isTest: boolean;
    createdDate: Date;
    surveyCompleted: boolean;
}

export interface ExtensionConfiguration {
    survey: Survey | undefined;
    extensionName: string;
    configuration: string;
}

export interface Anonymous2 {
    Item: Label | undefined;
    Default: Label | undefined;
}

export interface LabelCollectionOfLabel extends Anonymous2 {
}

export interface Label {
    value: string | undefined;
    language: string | undefined;
}

export interface SurveyLogic {
    condition: SurveyLogicCondition | undefined;
    expressions: SurveyLogic[] | undefined;
    validationMessages: LabelCollectionOfLabel | undefined;
    value: string | undefined;
    question: QuestionPartView | undefined;
    operator: SurveyLogicOperator | undefined;
}

export enum SurveyLogicCondition {
    And = "and",
    Or = "or",
}

export interface QuestionPartView {
    labels: LabelCollectionOfLabel | undefined;
    questionPart: QuestionPart | undefined;
    parentView: QuestionPartView | undefined;
    conditionals: QuestionConditionalOperator[] | undefined;
    surveyView: SurveyView | undefined;
    questionPartViewChildren: QuestionPartView[] | undefined;
    order: number;
    isOptional: boolean;
    isHousehold: boolean;
    isMultiView: boolean;
    isDefaultHidden: boolean;
    repeatSource: QuestionPart | undefined;
    icon: string | undefined;
    catiDependent: QuestionPartView | undefined;
}

export interface QuestionPart {
    questionType: string | undefined;
    name: string | undefined;
    questionPartChildren: QuestionPart[] | undefined;
    questionConfigurations: QuestionConfiguration[] | undefined;
    questionOptions: QuestionOption[] | undefined;
    questionConditionalsSource: QuestionConditional[] | undefined;
    questionConditionalsTarget: QuestionConditional[] | undefined;
    questionOptionConditionalsSource: QuestionOptionConditional[] | undefined;
    isGroupQuestion: boolean;
    survey: Survey | undefined;
}

export interface QuestionConfiguration {
    name: string | undefined;
    value: string | undefined;
    isResourceOnly: boolean;
    valueType: ConfigurationValueType;
    questionConfigurationLabels: LabelCollectionOfLabel | undefined;
    isSourceInputRequired: boolean;
}

export enum ConfigurationValueType {
    String = "string",
    Integer = "integer",
    Decimal = "decimal",
    Boolean = "boolean",
    Tuple = "tuple",
    Time = "time",
    Date = "date",
    Custom = "custom",
    Label = "label",
    Question = "question",
    KeyValuePair = "keyValuePair",
}

export interface QuestionOption {
    name: string | undefined;
    code: string | undefined;
    questionOptionLabels: LabelCollectionOfLabel | undefined;
    order: number;
    questionOptionConditionalsTarget: QuestionOptionConditional[] | undefined;
    questionPartParent: QuestionPart | undefined;
}

export interface QuestionOptionConditional {
    targetOption: QuestionOption | undefined;
    sourceQuestion: QuestionPart | undefined;
    condition: QuestionConditionalType;
    value: string | undefined;
}

export enum QuestionConditionalType {
    IsEqualTo = "Is Equal To",
    IsNotEqualTo = "Is Not Equal To",
    GreaterThan = "Greater Than",
    LessThan = "Less Than",
    InBounds = "In Bounds",
    OutOfBounds = "Out Of Bounds",
    InRange = "In Range",
    OutsideRange = "Outside Range",
    IsAnyOf = "Is Any Of",
    IsAllOf = "Is All Of",
    Contains = "Contains",
    DoesNotContain = "Does Not Contain",
}

export interface QuestionConditional {
    sourceQuestion: QuestionPartView | undefined;
    sourceQuestionId: number;
    condition: QuestionConditionalType;
    value: string | undefined;
}

export interface QuestionConditionalOperator {
    order: number;
    operatorType: QuestionCondtionalOperatorType;
    lhs: QuestionConditional | undefined;
    rhs: QuestionConditional | undefined;
    targetQuestionId: number;
    lhsId: number | undefined;
    rhsId: number | undefined;
}

export enum QuestionCondtionalOperatorType {
    AND = "AND",
    OR = "OR",
}

export enum SurveyLogicOperator {
    Equals = "=",
    NotEquals = "!=",
    GreaterThan = ">",
    GreaterThanEqualTo = ">=",
    LessThan = "<",
    LessThanEqualTo = "<=",
    Contains = "contains",
    Like = "like",
    AnyOf = "any of",
    AllOf = "all of",
    NoneOf = "none of",
}

export interface QuestionPartViewViewModel {
    questionChildren: QuestionPartViewViewModel[] | undefined;
    id: number;
    label: string | undefined;
    order: number;
    questionType: string | undefined;
}

export enum SurveyViewType {
    RespondentView = "respondentView",
    CatiView = "catiView",
}

export interface QuestionOptionsViewModel {
}

export interface SurveyViewerViewModel {
    questions: QuestionPartViewViewModel[] | undefined;
    id: number;
    viewName: string | undefined;
    survey: SurveyViewModel | undefined;
    titleText: string | undefined;
    termsAndConditionsText: string | undefined;
    welcomeText: string | undefined;
    surveyCompletionText: string | undefined;
    screeningQuestions: string[] | undefined;
}

export interface SurveyViewModel {
    id: number;
    code: string | undefined;
    name: string | undefined;
    owner: string | undefined;
    group: string | undefined;
    createdDate: Date;
    updatedDate: Date;
    startAt: Date;
    endAt: Date;
    isActive: boolean;
    isOpen: boolean;
    successLink: string | undefined;
    rejectionLink: string | undefined;
    defaultLanguage: string | undefined;
    styleTemplate: string | undefined;
    surveyPermissions: SurveyPermissionViewModel[] | undefined;
}

export interface SurveyPermissionViewModel {
    id: number;
    userId: string | undefined;
    surveyId: number;
    permissions: string[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}